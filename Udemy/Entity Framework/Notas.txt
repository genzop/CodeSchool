Database-First
    Primeros Pasos    
        - 1° Crear la base de datos y sus respectivas tablas.
        - 2° Crear un proyecto
        - 3° Instalar Entity Framework ('install-package EntityFramework')
        - 4° Agregar un archivo ADO.NET Entity Data Model (.edmx) que apuntará a la base de datos creada en el paso anterior.   

        - Es posible instalar Entity Framework en la configuración del archivo .edmx

    Diagrama de Entidades (archivo .edmx)
        - Ordernar
            "Click derecho -> Diagram -> Layout Diagram"
        - Exportar a una imagen
            "Click derecho -> Diagram -> Export as Image..."
        - Mostrar tipo de datos
            "Click derecho -> Scalar Property Format -> Display Name and Type"
        - Es posible cambiar el nombre de una entidad

        - Navigation Properties: permite navegar de una entidad a otra

        - Una propiedad puede ser configurada para que no sea persistida a  la base de datos, para esto:
            "Click derecho sobre la entidad -> Table Mapping -> Column Mappings (Columna <-> Propiedad) -> <Delete>"

        Esta compuesto por tres partes
            Storage model: representa la estructura de la base de datos.
            Conceptual model: representa la estructura del modelo.
            Mapping: representa el mapeo entre el storage model y el conceptual model.

    Connection Strings
        Se encuentran en el archivo App.config o Web.config
            - Data Source: nombre de la instancia de SQL Server
            - Initial Catalog: nombre de la Base de datos
            - Integrated Security: especifica si se utiliza la seguridad integrada de Windows
        
    Cambios en la Base de Datos
        - Agregar tabla
            - 1° Agregar tabla en la base de datos
            - 2° En el archivo .edmx 
                "Click derecho sobre el fondo -> Update Model from Database -> Tables -> Seleccionar las tablas que se deseen agregar -> Finish"

        - Actualizar tabla 
            - 1° Realizar cambios en la base de datos
            - 2° En el archivo .edmx 
                "Click derecho sobre el fondo -> Update Model from Database -> Finish"
            - 3° En caso de que salte algun error es muy probable que haya que revisar el mapeo del modelo conceptual y modificar o eliminar alguna propiedad.
                ! Cuando se cambia el tipo de dato de alguna columna, Entity Framework no actualiza el tipo de dato de su propiedad correspondiente, asi que hay que cambiarlo a mano y para ello:
                    "Click derecho sobre la propiedad -> Properties -> Type -> Seleccionar el nuevo tipo de datos"                    

            - Es posible validar el modelo de la siguiente manera
                "Click derecho sobre el fondo -> Validate"

        - Eliminar tabla
            - 1° Eliminar tabla en la base de datos
            - 2° En el archivo .edmx 
                "Click derecho sobre el fondo -> Update Model from Database -> Finish"
            - 3° Eliminar entidad del Conceptual model, ya que Entity Framework no la elimina automaticamente

    Importar Stored Procedures
        - En el archivo .edmx 
            "Click derecho sobre el fondo -> Update Model from Database -> Stored Procedures and Functions -> Seleccionar los SP's que se deseen importar -> Finish"
            !Es muy importante que el checkbox con la etiqueta "Import selected stored procedures and functions into the entity model" este seleccionado
        
        - Todos los SP's que se importen son incluidos en el DbContext como funciones

    Function Imports
        - Function Import Name: nombre que tendra el método
        - Stored Procedure/Function Name: nombre del SP
        - Returns a Collection Of: tipo de dato que devolvera el método, puede ser uno de los siguientes:
            None: no devuelve nada
            Scalars: tipo de dato primitivo
            Complex: tipo de dato que puede ser modificado sin alterar la base de datos, funcionamiento similar a un DTO
                - Para crear un tipo complex:
                    "Seleccionamos complex -> Get Column Information -> Create New Complex Type -> Cambiar el nombre de la clase de ser necesario -> Finish"

            Entities: entidad de Entity Framework

    Enumeraciones 
        - Es posible asignar una enum al tipo de dato de una propiedad en el modelo.
        - Es necesario que el tipo de dato de la columna y el de la enum sean iguales.
        
        - Crear enum en el modelo
            "Model Browser -> Concetual Model -> Enum Types -> Add Enum Type"
                Enum Type Name: nombre del enum
                Unerlying Type: tipo de dato del enum, generalmente es Int32
                Member Name: nombre
                Value: valor

        - Importar enum externa
            "Model Browser -> Concetual Model -> Enum Types -> Add Enum Type"
                El nombre de la enum debe ser exactamente igual a la enum externa

        
        
Code-First 
    Primeros pasos creando una base de datos nueva
        - 1° Crear un proyecto
        - 2° Instalar Entity Framework ('install-package EntityFramework')
                Podemos instalar una versión en particular de la siguiente manera
                    "install-package EntityFramework -Version:6.1.3"
        - 3° Crear las clases
        - 4° Crear un DbContext que herede de DbContext
        - 5° Agregar un connection string en el config
        - 6° Habilitar migraciones ('enable-migrations')
        - 7° Agregar una migración inicial ('add-migration NombreDeLaMigracion')
        - 8° Actualizar la base de datos ('update-database')

    Cada migracion cuenta con dos metodos:
        - Up(): sirve para hacer un upgrade a una base de datos
        - Down(): sirve para hacer un downgrade a una base de datos
      Esto permite poder llevar una base de datos a cualquier versión.

    Utilizando una base de datos existente
        - 1° Se genera un modelo a partir de la base de datos
            - Agregamos un archivo ADO.NET Entity Data Model
            - Seleccionamos la opcion 'Code First from Database'
            - Agregamos las tablas menos la tabla denominada "_MigrationHistory"
        - 2° Se crea una migracion inicial que no intente crear nuevamente las tablas, para ello:
            "add-migration InitialModel -IgnoreChanges -Force"
        - 3° Se utilizan migraciones para actualizar la base de datos

    Migraciones
        - !Solo puede haber una sola migración pendiente 
        - !Siempre realizar cambios pequeños en cada migración
        - El comando -Force hace que la nueva migracion pise una migración anterior que tenga el mismo nombre
        - !El tipo de dato Datetime no es nullable por defecto, es necesario agregarle un ?
        - !Siempre que se modifica algo en el metodo Up de la migración, se debe modificar de manera opuesta en el método Down
    
    Ejecutar una consulta SQL personalizada en una migracion
        Se puede ejecutar una consulta SQL personalizada en una migración agregando el comando: 
            "Sql(consulta)"
    
    Agregar una clase al modelo
        1° Crear la clase
        2° Agregar el DbSet al DbContext
        3° Agregar una migracion
            La migracion puede nombrarse basandose en formas diferentes:
                - Model Centric: "AddCategory"
                - Database Centric: "AddCategoriesTable"
            Se recomienda utilizar nombres Database Centric.
    
    Modificar una clase del modelo
        - Agregar una propiedad
            1° Agregar la propiedad en la clase                
            2° Agregar una migracion
                Si quiero puedo setearle un valor por defecto utilizando el comando Sql
            
        - Renombrar una propiedad
            1° Renombrar la propiedad en la clase
            2° Agregar una migracion
                Existen dos formas de realizar este cambios:
                    - Agregando la nueva columna, establecerle el valor de la columna vieja y eliminando la columna vieja
                        "AddColumn("dbo.Courses", "Name", c => c.String(nullable:  false));"
                        "Sql("UPDATE Courses SET Name = Title");"
                        "DropColumn("dbo.Courses", "Title");" 
                    - Renombrando la columna
                        "RenameColumn("dbo.Courses", "Title", "Name");"
            3° Actualizar la base de datos
        - Eliminar una propiedad
            1° Eliminar la propiedad de la clase
            2° Agregar una migracion
            3° Actualizar la base de datos
    
    Eliminar una clase del modelo 
        1° Eliminar cualquier asociacion que haya con otras clases
        2° Agregar una migracion
        3° Actualizar la base de datos
        4° Eliminar la clase y su DbSet del DbContext
        5° Agregar una migracion    
        6° Actualizar la base de datos

    Recuperarse de un error 
        Para recuperarse de un error se debe agregar una nueva migracion que solucione el error. Eliminar la migracion no arreglara nada solo complicara las cosas.

    Downgrade una base de datos
        Para llevar una base de datos a una migracion en particular se utiliza el siguiente comando:
            "Update-Database -TargetMigration:NombreMigracion"

        Para volver a la ultima migracion utilizamos el comando:
            "Update-Database"
    
    Configuracion
        Migraciones automáticas
            Si esta opción se activa, la base de datos es actualizada automaticamente la primera vez que se ejecuta la aplicación. Esto no se recomienda en absoluto ya que es muy arriesgado no tener un control sobre que cambios se realizan en la base de datos.                   
                
        Seeding una base de datos
            El metodo seed sirve para inicializar la base de datos con información de ejemplo para el desarrollo.
            Esto ocurre en el método Seed donde se utilizan expresiones como la siguiente:
               "context.Authors.AddOrUpdate(
                    a => a.Name,            
                    new Author
                    {
                        Name = "Author 1",
                        Courses = new Collection<Course>()
                        {
                            new Course { Name = "Course for Author 1", Description = "Description" }
                        }
                    });"

            El primer parámetro del metodo AddOrUpdate hace referencia a la propiedad del objeto que se utilizara para comprobar si el registro ya existe y asi no crearlo nuevamente.

    Generar script SQL
        Para poder generar un script SQL de todas las migraciones, se utiliza el siguiente comando:
            "Update-Database -Script -SourceMigration:0"
            
        Si en cambio, se desea crear un script desde y hasta una migracion en particular se utiliza este comando:
            "Update-Database -Script -SourceMigration:NombreMigracion1 -TargetMigration:NombreMigracion2"
            
    Sobreescribir convenciones de Code First
        El enfoque Code First se basa en convenciones y no tanto en configuracion. Por lo que muchas cosas se establecen de manera automática. 
        Pero, es posible sobreescribir estas convenciones y personalizar el esquema como uno quiera:
            - Data Annotations
                Son meta etiquetas que van sobre una propiedad en una de las clases del modelo.
                    [Required]                      
                    public string Description { get; set; }      

                - Cambiar nombre de una tabla
                    [Table("nombre", Schema = "")]   

                - Cambiar nombre de una columna
                    [Column("nombre", TypeName = "varchar")]

                - Asignar Primary Key y configurar identidad
                    [Key]           
                    [DatabaseGenerated(DatabaseGeneratedOption.None)]

                - Asignar Key compuestas
                    [Key]
                    [Column(Order = 1)]

                - Volver propiedad no nullable
                    [Required]  

                - Configurar el largo de un string
                    [MaxLength(255)]
                
                - Agregar un indice
                    [Index(IsUnique = true)]

                    Multiple columnas
                    [Index("nombre"), 1]
                    
                    [Index("nombre"), 2]
                
                - Asignar Foreing Key
                    1° Se agrega una propiedad para el ID de la otra clase
                        public int AuthorId { get; set; }
                    2° Se agrega una propiedad para la relacion con la otra clase
                        public Author Author { get; set; }
                    3° Se debe asociar esa propiedad con el puntero a la otra clase, lo cual puede hacer se de dos maneras, puede ser en el id o en la propiedad misma:
                        - [ForeignKey("Author")]
                          public int AuthorId { get; set; }

                        - [ForeignKey("AuthorId")]
                          public Author Author{ get; set; }
                    
            - Fluent API
                Son instrucciones que se especifican en el método OnModelCreating del DbContext
                    modelBuilder.Entity<Course>()           //Selecciona la entidad 
                        .Property(x => x.Description)       //Selecciona una propiedad de la entidad
                        .IsRequired();                      //Hace que esa columna no pueda ser nullable

                Las instrucciones parten del modelBuilder que es el objeto que recibe este metodo.

                - Cambiar nombre de una tabla
                    modelBuilder.Entity<Course>()
                                    .ToTable("nombreTabla", "esquema");

                - Cambiar nombre de una columna
                    modelBuilder.Entity<Course>
                                .Property(x => x.Name)
                                .HasColumnName("nombre");

                - Cambiar el tipo de dato de una columna
                    modelBuilder.Entity<Course>
                                .Property(x => x.Name)
                                .HasColumnType("varchar");

                - Cambiar el orden de las columnas
                    modelBuilder.Entity<Course>()
                                .Property(x => x.Name)
                                .HasColumnOrder(2);

                - Asignar Primary Key
                    modelBuilder.Entity<Book>()
                                .HasKey(x => x.ISBN);

                - Configurar identidad de una columna
                    modelBuilder.Entity<Book>()
                                .Property(x => x.ISBN)
                                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.None)

                - Asignar Key compuestas
                    modelBuilder.Entity<OrderItem>()
                                .HasKey(x => new { x.OrderId, x.OrderItemId });

                - Volver propiedad no nullable
                    modelBuilder.Entity<Course>()
                                .Property(x => x.Name)
                                .IsRequired();

                - Configurar el largo de un string
                    modelBuilder.Entity<Course>()
                                .Property(x => x.Name)
                                .HasMaxLength(255);

                - Configura el largo de un string al máximo
                    modelBuilder.Entity<Course>()
                                .Property(x => x.Name)
                                .IsMaxLength();
                
                - Relaciones
                    Las relaciones se configuran desde ambas entidades, y existen metodos para cado de la relacion.
                    Los metodos que comienzan con Has, son aquellos que contienen la Foreign Key:
                        - HasMany() / WithMany(): cuando hay muchas entidades del otro lado
                        - HasRequired() / WithRequired(): cuando hay una entidad obligatoria del otro lado
                        - HasOptional() / WithOptional(): cuando puede haber ninguna o una entidad del otro lado

                    One-to-Many
                        modelBuilder.Entity<Author>()
                                    .HasMany(a => a.Courses)
                                    .WithRequired(c => c.Author)
                                    .HasForeignKey(c => c.AuthorId); 

                    Many-to-Many
                        modelBuilder.Entity<Course>()
                                    .HasMany(c => c.Tags)
                                    .WithMany(t => t.Courses)
                                    .Map(m => m.ToTable("CourseTags"));         //Se personaliza el nombre de la tabla intermediaria

                    One-to-Zero/One
                        modelBuilder.Entity<Course>()
                                    .HasOptional(c => c.Caption)
                                    .WithRequired(c => c.Course);

                    One-to-One
                        modelBuilder.Entity<Course>()
                                    .HasRequired(c => c.Cover)
                                    .WithRequiredPrincipal(c => c.Course);                   

                        modelBuilder.Entity<Cover>()
                                    .HasRequired(c => c.Course)
                                    .WithRequiredDependent(c => c.Cover);


            !No se recomienda mezclar los enfoques, para proyectos de gran escala se recomienda utilizar Fluent API y para proyectos pequeños no deberia haber problemas utilizando Data Annotations.
