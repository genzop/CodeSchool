Database-First
    Primeros Pasos    
        - 1° Crear la base de datos y sus respectivas tablas.
        - 2° Crear un proyecto
        - 3° Instalar Entity Framework ('install-package EntityFramework')
        - 4° Agregar un archivo ADO.NET Entity Data Model (.edmx) que apuntará a la base de datos creada en el paso anterior.   

        - Es posible instalar Entity Framework en la configuración del archivo .edmx

    Diagrama de Entidades (archivo .edmx)
        - Ordernar
            "Click derecho -> Diagram -> Layout Diagram"
        - Exportar a una imagen
            "Click derecho -> Diagram -> Export as Image..."
        - Mostrar tipo de datos
            "Click derecho -> Scalar Property Format -> Display Name and Type"
        - Es posible cambiar el nombre de una entidad

        - Navigation Properties: permite navegar de una entidad a otra

        - Una propiedad puede ser configurada para que no sea persistida a  la base de datos, para esto:
            "Click derecho sobre la entidad -> Table Mapping -> Column Mappings (Columna <-> Propiedad) -> <Delete>"

        Esta compuesto por tres partes
            Storage model: representa la estructura de la base de datos.
            Conceptual model: representa la estructura del modelo.
            Mapping: representa el mapeo entre el storage model y el conceptual model.

    Connection Strings
        Se encuentran en el archivo App.config o Web.config
            - Data Source: nombre de la instancia de SQL Server
            - Initial Catalog: nombre de la Base de datos
            - Integrated Security: especifica si se utiliza la seguridad integrada de Windows
        
    Cambios en la Base de Datos
        - Agregar tabla
            - 1° Agregar tabla en la base de datos
            - 2° En el archivo .edmx 
                "Click derecho sobre el fondo -> Update Model from Database -> Tables -> Seleccionar las tablas que se deseen agregar -> Finish"

        - Actualizar tabla 
            - 1° Realizar cambios en la base de datos
            - 2° En el archivo .edmx 
                "Click derecho sobre el fondo -> Update Model from Database -> Finish"
            - 3° En caso de que salte algun error es muy probable que haya que revisar el mapeo del modelo conceptual y modificar o eliminar alguna propiedad.
                ! Cuando se cambia el tipo de dato de alguna columna, Entity Framework no actualiza el tipo de dato de su propiedad correspondiente, asi que hay que cambiarlo a mano y para ello:
                    "Click derecho sobre la propiedad -> Properties -> Type -> Seleccionar el nuevo tipo de datos"                    

            - Es posible validar el modelo de la siguiente manera
                "Click derecho sobre el fondo -> Validate"

        - Eliminar tabla
            - 1° Eliminar tabla en la base de datos
            - 2° En el archivo .edmx 
                "Click derecho sobre el fondo -> Update Model from Database -> Finish"
            - 3° Eliminar entidad del Conceptual model, ya que Entity Framework no la elimina automaticamente

    Importar Stored Procedures
        - En el archivo .edmx 
            "Click derecho sobre el fondo -> Update Model from Database -> Stored Procedures and Functions -> Seleccionar los SP's que se deseen importar -> Finish"
            !Es muy importante que el checkbox con la etiqueta "Import selected stored procedures and functions into the entity model" este seleccionado
        
        - Todos los SP's que se importen son incluidos en el DbContext como funciones

    Function Imports
        - Function Import Name: nombre que tendra el método
        - Stored Procedure/Function Name: nombre del SP
        - Returns a Collection Of: tipo de dato que devolvera el método, puede ser uno de los siguientes:
            None: no devuelve nada
            Scalars: tipo de dato primitivo
            Complex: tipo de dato que puede ser modificado sin alterar la base de datos, funcionamiento similar a un DTO
                - Para crear un tipo complex:
                    "Seleccionamos complex -> Get Column Information -> Create New Complex Type -> Cambiar el nombre de la clase de ser necesario -> Finish"

            Entities: entidad de Entity Framework

    Enumeraciones 
        - Es posible asignar una enum al tipo de dato de una propiedad en el modelo.
        - Es necesario que el tipo de dato de la columna y el de la enum sean iguales.
        
        - Crear enum en el modelo
            "Model Browser -> Concetual Model -> Enum Types -> Add Enum Type"
                Enum Type Name: nombre del enum
                Unerlying Type: tipo de dato del enum, generalmente es Int32
                Member Name: nombre
                Value: valor

        - Importar enum externa
            "Model Browser -> Concetual Model -> Enum Types -> Add Enum Type"
                El nombre de la enum debe ser exactamente igual a la enum externa

        
        
Code-First 
    Primeros pasos creando una base de datos nueva
        - 1° Crear un proyecto
        - 2° Instalar Entity Framework ('install-package EntityFramework')
                Podemos instalar una versión en particular de la siguiente manera
                    "install-package EntityFramework -Version:6.1.3"
        - 3° Crear las clases
        - 4° Crear un DbContext que herede de DbContext
        - 5° Agregar un connection string en el config
        - 6° Habilitar migraciones ('enable-migrations')
        - 7° Agregar una migración inicial ('add-migration NombreDeLaMigracion')
        - 8° Actualizar la base de datos ('update-database')

    Cada migracion cuenta con dos metodos:
        - Up(): sirve para hacer un upgrade a una base de datos
        - Down(): sirve para hacer un downgrade a una base de datos
      Esto permite poder llevar una base de datos a cualquier versión.

    Utilizando una base de datos existente
        - 1° Se genera un modelo a partir de la base de datos
            - Agregamos un archivo ADO.NET Entity Data Model
            - Seleccionamos la opcion 'Code First from Database'
            - Agregamos las tablas menos la tabla denominada "_MigrationHistory"
        - 2° Se crea una migracion inicial que no intente crear nuevamente las tablas, para ello:
            "add-migration InitialModel -IgnoreChanges -Force"
        - 3° Se utilizan migraciones para actualizar la base de datos

    Migraciones
        - !Solo puede haber una sola migración pendiente 
        - !Siempre realizar cambios pequeños en cada migración
        - El comando -Force hace que la nueva migracion pise una migración anterior que tenga el mismo nombre
        - !El tipo de dato Datetime no es nullable por defecto, es necesario agregarle un ?
        - !Siempre que se modifica algo en el metodo Up de la migración, se debe modificar de manera opuesta en el método Down
    
    Ejecutar una consulta SQL personalizada en una migracion
        Se puede ejecutar una consulta SQL personalizada en una migración agregando el comando: 
            "Sql(consulta)"
    
    Agregar una clase al modelo
        1° Crear la clase
        2° Agregar el DbSet al DbContext
        3° Agregar una migracion
            La migracion puede nombrarse basandose en formas diferentes:
                - Model Centric: "AddCategory"
                - Database Centric: "AddCategoriesTable"
            Se recomienda utilizar nombres Database Centric.
    
    Modificar una clase del modelo
        - Agregar una propiedad
            1° Agregar la propiedad en la clase                
            2° Agregar una migracion
                Si quiero puedo setearle un valor por defecto utilizando el comando Sql
            
        - Renombrar una propiedad
            1° Renombrar la propiedad en la clase
            2° Agregar una migracion
                Existen dos formas de realizar este cambios:
                    - Agregando la nueva columna, establecerle el valor de la columna vieja y eliminando la columna vieja
                        "AddColumn("dbo.Courses", "Name", c => c.String(nullable:  false));"
                        "Sql("UPDATE Courses SET Name = Title");"
                        "DropColumn("dbo.Courses", "Title");" 
                    - Renombrando la columna
                        "RenameColumn("dbo.Courses", "Title", "Name");"
            3° Actualizar la base de datos
        - Eliminar una propiedad
            1° Eliminar la propiedad de la clase
            2° Agregar una migracion
            3° Actualizar la base de datos
    
    Eliminar una clase del modelo 
        1° Eliminar cualquier asociacion que haya con otras clases
        2° Agregar una migracion
        3° Actualizar la base de datos
        4° Eliminar la clase y su DbSet del DbContext
        5° Agregar una migracion    
        6° Actualizar la base de datos

    Recuperarse de un error 
        Para recuperarse de un error se debe agregar una nueva migracion que solucione el error. Eliminar la migracion no arreglara nada solo complicara las cosas.

    Downgrade una base de datos
        Para llevar una base de datos a una migracion en particular se utiliza el siguiente comando:
            "Update-Database -TargetMigration:NombreMigracion"

        Para volver a la ultima migracion utilizamos el comando:
            "Update-Database"
    
    Configuracion
        Migraciones automáticas
            Si esta opción se activa, la base de datos es actualizada automaticamente la primera vez que se ejecuta la aplicación. Esto no se recomienda en absoluto ya que es muy arriesgado no tener un control sobre que cambios se realizan en la base de datos.                   
                
        Seeding una base de datos
            El metodo seed sirve para inicializar la base de datos con información de ejemplo para el desarrollo.
            Esto ocurre en el método Seed donde se utilizan expresiones como la siguiente:
               "context.Authors.AddOrUpdate(
                    a => a.Name,            
                    new Author
                    {
                        Name = "Author 1",
                        Courses = new Collection<Course>()
                        {
                            new Course { Name = "Course for Author 1", Description = "Description" }
                        }
                    });"

            El primer parámetro del metodo AddOrUpdate hace referencia a la propiedad del objeto que se utilizara para comprobar si el registro ya existe y asi no crearlo nuevamente.

    Generar script SQL
        Para poder generar un script SQL de todas las migraciones, se utiliza el siguiente comando:
            "Update-Database -Script -SourceMigration:0"
            
        Si en cambio, se desea crear un script desde y hasta una migracion en particular se utiliza este comando:
            "Update-Database -Script -SourceMigration:NombreMigracion1 -TargetMigration:NombreMigracion2"
            
    Sobreescribir convenciones de Code First
        El enfoque Code First se basa en convenciones y no tanto en configuracion. Por lo que muchas cosas se establecen de manera automática. 
        Pero, es posible sobreescribir estas convenciones y personalizar el esquema como uno quiera:
            - Data Annotations
                Son meta etiquetas que van sobre una propiedad en una de las clases del modelo.
                    [Required]                      
                    public string Description { get; set; }      

                - Cambiar nombre de una tabla
                    [Table("nombre", Schema = "")]   

                - Cambiar nombre de una columna
                    [Column("nombre", TypeName = "varchar")]

                - Asignar Primary Key y configurar identidad
                    [Key]           
                    [DatabaseGenerated(DatabaseGeneratedOption.None)]

                - Asignar Key compuestas
                    [Key]
                    [Column(Order = 1)]

                - Volver propiedad no nullable
                    [Required]  

                - Configurar el largo de un string
                    [MaxLength(255)]
                
                - Agregar un indice
                    [Index(IsUnique = true)]

                    Multiple columnas
                    [Index("nombre"), 1]
                    
                    [Index("nombre"), 2]
                
                - Asignar Foreing Key
                    1° Se agrega una propiedad para el ID de la otra clase
                        public int AuthorId { get; set; }
                    2° Se agrega una propiedad para la relacion con la otra clase
                        public Author Author { get; set; }
                    3° Se debe asociar esa propiedad con el puntero a la otra clase, lo cual puede hacer se de dos maneras, puede ser en el id o en la propiedad misma:
                        - [ForeignKey("Author")]
                          public int AuthorId { get; set; }

                        - [ForeignKey("AuthorId")]
                          public Author Author{ get; set; }
                    
            - Fluent API
                Son instrucciones que se especifican en el método OnModelCreating del DbContext
                    modelBuilder.Entity<Course>()           //Selecciona la entidad 
                        .Property(x => x.Description)       //Selecciona una propiedad de la entidad
                        .IsRequired();                      //Hace que esa columna no pueda ser nullable

                Las instrucciones parten del modelBuilder que es el objeto que recibe este metodo.

                - Cambiar nombre de una tabla
                    modelBuilder.Entity<Course>()
                                    .ToTable("nombreTabla", "esquema");

                - Cambiar nombre de una columna
                    modelBuilder.Entity<Course>
                                .Property(x => x.Name)
                                .HasColumnName("nombre");

                - Cambiar el tipo de dato de una columna
                    modelBuilder.Entity<Course>
                                .Property(x => x.Name)
                                .HasColumnType("varchar");

                - Cambiar el orden de las columnas
                    modelBuilder.Entity<Course>()
                                .Property(x => x.Name)
                                .HasColumnOrder(2);

                - Asignar Primary Key
                    modelBuilder.Entity<Book>()
                                .HasKey(x => x.ISBN);

                - Configurar identidad de una columna
                    modelBuilder.Entity<Book>()
                                .Property(x => x.ISBN)
                                .HasDatabaseGeneratedOption(DatabaseGeneratedOption.None)

                - Asignar Key compuestas
                    modelBuilder.Entity<OrderItem>()
                                .HasKey(x => new { x.OrderId, x.OrderItemId });

                - Volver propiedad no nullable
                    modelBuilder.Entity<Course>()
                                .Property(x => x.Name)
                                .IsRequired();

                - Configurar el largo de un string
                    modelBuilder.Entity<Course>()
                                .Property(x => x.Name)
                                .HasMaxLength(255);

                - Configura el largo de un string al máximo
                    modelBuilder.Entity<Course>()
                                .Property(x => x.Name)
                                .IsMaxLength();
                
                - Relaciones
                    Las relaciones se configuran desde ambas entidades, y existen metodos para cado de la relacion.
                    Los metodos que comienzan con Has, son aquellos que contienen la Foreign Key:
                        - HasMany() / WithMany(): cuando hay muchas entidades del otro lado
                        - HasRequired() / WithRequired(): cuando hay una entidad obligatoria del otro lado
                        - HasOptional() / WithOptional(): cuando puede haber ninguna o una entidad del otro lado

                    One-to-Many
                        modelBuilder.Entity<Author>()
                                    .HasMany(a => a.Courses)
                                    .WithRequired(c => c.Author)
                                    .HasForeignKey(c => c.AuthorId); 

                    Many-to-Many
                        modelBuilder.Entity<Course>()
                                    .HasMany(c => c.Tags)
                                    .WithMany(t => t.Courses)
                                    .Map(m => m.ToTable("CourseTags"));         //Se personaliza el nombre de la tabla intermediaria

                    One-to-Zero/One
                        modelBuilder.Entity<Course>()
                                    .HasOptional(c => c.Caption)
                                    .WithRequired(c => c.Course);

                    One-to-One
                        modelBuilder.Entity<Course>()
                                    .HasRequired(c => c.Cover)
                                    .WithRequiredPrincipal(c => c.Course);                   

                        modelBuilder.Entity<Cover>()
                                    .HasRequired(c => c.Course)
                                    .WithRequiredDependent(c => c.Cover);


            !No se recomienda mezclar los enfoques, para proyectos de gran escala se recomienda utilizar Fluent API y para proyectos pequeños no deberia haber problemas utilizando Data Annotations.

LINQ
    Puede ser utilizado con objetos, xml, bases de datos relacionales y bases de datos NoSQL.
    No esta diseñado para consultas complejas.

    LINQ Syntax
        var query = from c in context.Courses
                    where c.Level == 1 && c.Author.Id == 1
                    orderby c.Level descending, c.Name
                    select new { Name = c.Name, Author = c.Author.Name };  

        !!Usar el comando equals y no ==

        Origen de los datos: el origen de los datos se especifica en la primer linea de la consulta:
            "from c in context.Courses"
        
        Restricciones: las restricciones van despues de la palabra 'where'
            "where c.Name == 'C# Course' && c.Level == 1"

        Ordenamiento: las reglas de ordenamiento van despues de la palabra 'orderby', van de más importante a menos importante y pueden ser ascendentes o descendentes
            "orderby c.Level descending, c.Name" 

        Proyeccion: se puede especificar si se desea cargar en memoria todo el objeto, una propiedad o un objeto anonimo con las propiedades que se desee
            "select c" / "select c.Name" / "select new { Name = c.Name, }"

        Agrupamiento: se pueden agrupar los resultados en diferentes grupos
            "group c by c.Level into g"

        Joins
            Inner Join: se utiliza inner join cuando dos entidades no estan relacionadas
               "var innerJoin = from c in context.Courses
                                join a in context.Authors on c.AuthorId equals a.Id
                                select new { CourseName = c.Name, AuthorName = a.Name };"
            
            Group Join: un group join nos permite agrupar los registros de una tabla dependiendo de la asociasion con otra tabla. Similar a cuando hacemos un left join en SQL
               "var groupJoin = from a in context.Authors
                                join c in context.Courses on a.Id equals c.AuthorId into g
                                select new { AuthorName = a.Name, Courses = g.Count() };"
        
            Cross Join: un cross join sirve para combinar todos los registros de dos o más tablas que esten asociados          
               "var crossJoin = from a in context.Authors
                                from c in context.Courses
                                select new { AuthorName = a.Name, CourseName = c.Name };"

    LINQ Extension Methods
        var query = context.Courses.Where(c => c.Name.Contains("c#")).OrderBy(c => c.Name);

        Restricciones: las restricciones se especifican en la funcion 'Where()'
            "var query = context.Courses.Where(c => c.Level == 1);"

        Ordenamiento: las reglas de ordenamiento dentro de las funciones "OrderBy()/OrderByDescending()" y "ThenBy()/ThenByDescending()".
            "var query = context.Courses.OrderByDescending(c => c.Name).ThenBy(c => c.Level);"

        Proyeccion: se puede especificar si se desea cargar en memoria todo el objeto, una propiedad o un objeto anonimo con las propiedades que se desee dentro del método "Select()"
            "var query = context.Courses.Select(c => new { CourseName = c.Name, AuthorName = c.Author.Name });"

            Si se desea cargar una lista de elementos, por ejemplo la lista de tags de un curso se utiliza el método "SelectMany()"
            "var query = context.Courses.SelectMany(c => c.Tags);"

        Distinct: el metodo "Distinct()" hace que no se pueda repetir ninguno de los resultados
            "var query = context.Courses.SelectMany(c => c.Tags).Distinct();"

        Agrupamiento: se pueden agrupar los resultados en diferentes grupos utilizando el comando "GroupBy()"
            "var groupBy = context.Courses.GroupBy(c => c.Level);"

        Joins
            Inner Join: se utiliza inner join cuando dos entidades no estan relacionadas, para esto se utiliza el comando "Join()"
                Parametros = con que tabla queremos hacer join, propiedad de la tabla original que queremos comparar, propiedad de la nueva tabla con la que queremos comparar, funcion que crea un objeto anonimo con el resultado.
                "var innerJoin = context.Courses.Join(context.Authors, c => c.AuthorId, a => a.Id, (course, author) => new { CourseName = course.Name, AuthorName = author.Name });"
            
            Group Join: un group join nos permite agrupar los registros de una tabla dependiendo de la asociasion con otra tabla. Similar a cuando hacemos un left join en SQL
                Parametros = con que tabla queremos hacer join, propiedad de la tabla original que queremos comparar, propiedad de la nueva tabla con la que queremos comparar, funcion que crea un objeto anonimo con el resultado.
                "var groupJoin = context.Authors.GroupJoin(context.Courses, a => a.Id, c => c.AuthorId, (author, courses) => new { Author = author, Courses = courses });"
        
            Cross Join: un cross join sirve para combinar todos los registros de dos o más tablas que esten asociados          
                var crossJoin = context.Authors.SelectMany(a => context.Courses, (author, course) => new { AuthorName = author.Name, CourseName = course.Name });

        Paginar resultados
            Para poder paginar los resultados de una consulta, se deben utilizar dos métodos: 
                Skip(cantidadDeRegistros): se saltea la cantidad de registros especificada
                Take(cantidadDeRegistros): carga la cantidad de registros especificada

        Operadores
            First/FirstOrDefault(): carga el primer objeto de la lista de resultados. Puede pasarse una expresión lambda como parámetro para filtrar la lista de resultados.

            Last/LastOrDefault(): carga el ultimo objeto de la lista de resultados.

            Single/SingleOrDefault(): carga un unico objeto. Puede pasarse una expresión lamda como parámetro para asignar una condicion a cumplir.

        Cuantificar
            All(): comprueba si todos los resultados cumplen con una condicion que debe ser especificada como parámetro.

            Any(): comprueba si alguno de los resultados cumple con una condicion que debe ser especificada como parámetro.

            Count(): devuelve la cantidad de resultados.

            Max(): el maximo de la propiedad que se especifique.

            Min(): el minimo de la propiedad que se especifique.

            Average(): busca el promedio de la propiedad que se especifique.
    
    Ejecución Diferida
        !Las consultas no se ejecutan en  el momento en que son creadas, se ejecutan en estas situaciones:
            - Cuando se itera sobre la variable 
            - Cuando se llama a los metodos ToList(), ToArray() o ToDictionary().
            - Cuando se llama a los metodos First(), Last(), Single(), Count(), Max(), Min(), Average().

        Esto permite que una consulta pueda ser extendida en más de una sentencia hasta que ocurra una de las situaciones mencionadas.
     
    Cargando objetos relacionados
        Lazy Loading
            Las entidades relacionadas no son cargadas automaticamente, son cargadas bajo demanda cuando intentamos acceder a ellas.            

            Para utilizar lazy loading, se debe poner la palabra "virtual" en la propiedad de navegacion
            
            Recomendaciones
                - Usarlo cuando el objeto que queramos cargar tenga muchas asociaciones a las que no necesitamos acceder.
                - Usarlo en aplicaciones de escritorio.
                - Evitarlo en aplicaciones web. 

            Se puede desactivar lazy loading desde el constructor del DbContext:
                "this.Configuration.LazyLoadingEnabled = false;"

            Problema N+1
                Si accedemos a una propiedad de navegacion de uno de las entidades dentro de una lista de N elementos, se ejecutaran N consultas a la base de datos para cargar esa propiedad de cada elemento.
        
        Eager Loading
            Las entidades relacionadas son cargadas en la consulta inicial.

            Para hacer esto, utilizamos el método "Include()" ya sea pasandole como parametro el nombre de la propiedad como cadena de texto o pasandole una expresión lambda que apunte a la propiedad.
                "var eagerLoading1 = context.Courses.Include("Author").ToList();
            var eagerLoading2 = context.Courses.Include(c => c.Author);" 

            Cargando multiples niveles
                Para propiedades que no son entidades
                    "context.Courses.Include(c => c.Author.Address);

                Para propiedades que son entidades
                    "context.Courses.Include(c => c.Tags.Select(t => t.Moderator))"

        Explicit Loading
            Las entidades relacionadas son cargadas en tandas. Para ello utilizamos el método "Load()".
                "var explicitLoading1 = context.Authors.Single(a => a.Id == 1);
                context.Courses.Where(c => c.AuthorId == explicitLoading1.Id).Load();"



            

