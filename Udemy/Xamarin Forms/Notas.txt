PCL es mejor que Shared.

Binding
    - Para vincular o bindear una propiedad de un view a otro view se debe ingresar lo siguiente
        '{Binding Source={x:Reference slider}, Path=Value, StringFormat='Value is {0:F2}' }'
            - Source: referencia al control con el que queremos vincular esta propiedad
            - Path: especifica a que propiedad de ese control queremos vincular
            - StringFormat: permite darle un formato especifico al valor obtenido del otro control

BindingContext
    - Se puede hacer lo mismo pero de una manera más limpia de la siguiente forma:
        - Se declara un BindingContext, que referencia a que control vamos a vincularnos
            'BindingContext={x:Reference slider}'
        - Se vinculan las propiedades con el objeto de la siguiente manera
            '{Binding Value, StringFormat='Value is {0:F2}'}'
    
    - El BindingContext puede setearse en cualquier elemento y todos los elementos dentro de el lo heredaran

Property Element Syntax
    - Se puede especificar un atributo de un elemento como si fuera un elemento más, es decir en vez de hacer lo siguiente:
        '<ContentPage xmlns="http://xamarin.com/schemas/2014/forms" xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"x:Class="HelloWorld.GreetPage"
            Padding="0, 20, 0 ,0"></ContentPage>'

        Se puede hacer de la siguiente manera:
        '<ContentPage xmlns="http://xamarin.com/schemas/2014/forms" xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml" x:Class="HelloWorld.GreetPage">
            <ContentPage.Padding></ContentPage.Padding>
         </ContentPage>'

Mostrar errores en tiempo de compilación
    - Para que el compilador agarre los errores y los muestre en tiempo de compilación, cada clase debe contener esta linea encima de su declaración
        '[XamlCompilation(XamlCompilationOptions.Compile)]'

StackLayout
    - Spacing: espacio que va a haber entre los elementos del StackLayout
    - Padding: espacio que va a haber entre el StackLayout y los elementos hijos
    - Orientation: en que dirección se van a apilar los elementos
    
    - Por defecto el StackLayout ocupa todo el espacio que tenga disponible, a menos que se le especifiquen HorizontalOptions y/o VerticalOptions.
    
Grid
    - RowSpacing: espacio entre filas
    - ColumnSpacing: espacio entre columnas

    Elementos del Grid
        - Grid.RowDefinitions: dentro de este elemento se puede definir el alto de cada fila especificamente, por ejemplo:
            '<RowDefinition Height="2*"/>'
            En este caso, el alto ocupara dos partes del espacio disponible, para ocupar una sola parte del espacio disponible se debe ingresar '*'
        
        - Grid.ColumnDefinitions. dentro de este elemento se puede definir el ancho de cada columna especificamente, por ejemplo:
            '<ColumnDefinition Width="Auto"/>'
            En este caso, el ancho de la columna se ajustará automáticamente

        - Contenido: dentro de un Grid se puede colocar cualquier elemento, pero es necesario especificar la fila y la columna de la siguiente manera:
            '<Label Grid.Row="0" Grid.Column="0" Text="Label"/>'

            - También es posible que un elemento ocupe más de una fila o más de una columna de la siguiente manera:
                '<Label Grid.Column="2" Grid.RowSpan="3" Text="RowSpan"/>'
                '<Label Grid.Row="2" Grid.ColumnSpan="3" Text="ColumnSpan"/>'

AbsoluteLayout
    - Este tipo de layout sirve especialmente para:
        - Anclar elementos a los limites de la pantalla.
        - Sobreposicionar elmentos uno sobre otro.
    
    - Para ubicar un elemento dentro de un AbsoluteLayout se debe utilizar el siguiente atributo:
        'AbsoluteLayout.LayoutBounds="0, 0, 1, 1"' 
        Donde los valores significan: Posicion X, Posicion Y, Ancho, Alto. Estos pueden ser valores absolutos o proporcionales, por defecto son absolutos.

        - Para utilizar valores proporcionales es necesario agregar el siguiente atributo:
            'AbsoluteLayout.LayoutFlags=""'
            Y seleccionar que propiedades queremos que sean proporcionales.
            

RelativeLayout
    - Sobreponer elementos encima de ellos
    - Aplicar restricciones basandose en otros elementos
    - Más control sobre la posición y tamaño de los Elementos

    - Setear el tamaño de un elemento en relación a su padre:
        'RelativeLayout.HeightConstraint="{ConstraintExpression Type=RelativeToParent, Property=Height, Factor=0.3}"'
            - RelativeLayout: propiedad del elemento que vamos a limitar
            - Type: indica que vamos a compararlo con el padre
            - Property: propiedad del elemento padre que vamos a tomar como referencia 
            - Factor: porcentaje que va a ocupar el elemento basandose en que en el padre el valor es de 1

    - Setear la posicion de un elemento en relación a otro elemento:
        'RelativeLayout.YConstraint="{ConstraintExpression Type=RelativeToView, ElementName=banner, Property=Height, Factor=1, Constant=20}"'
            - RelativeLayout: propiedad del elemento que vamos a limitar
            - Type: indica que vamos a compararlo con otro elemento
            - ElementName: nombre del elemento con el que vamos a compararlo
            - Property: propiedad del elemento que vamos a tomar como referencia 
            - Factor: porcentaje que va a ocupar el elemento basandose en que en el padre el valor es de 1
            - Constant: cantidad de unidades que queremos utilizar

Imagenes
    Descargadas
        - Para cambiar el source de una imagen desde el código se debe hacer lo siguiente:
            'var imageSource = new UriImageSource { Uri = new Uri("uriDeLaImagen") };'

        - CachingEnabled: habilita o deshabilita el cacheo de imagenes en el dispositivo.
        - CacheValidity: tiempo que la imagen será guardada en cache, por defecto es 24 horas.
            'imageSource.CacheValidity = TimeSpan.FromSeconds(10);'

    Aspectos
        - AspectFit: mantiene el aspecto de la imagen pero deja espacios vacios.
        - AspectFill: corta la imagen para que se adapte al espacio disponible
        - Fill: rellena el espacio estirando la imagen sin mantener el aspecto

    ActivityIndicator
        - Es posible vincular una imagen a un ActivityIndicator para mostrar que se esta descargando de la siguiente manera
            '<ActivityIndicator IsRunning="{Binding Source={x:Reference nameDeLaImagen}, Path=IsLoading}"/>'

    Embedded Resource
        - Cuando se agrege una imagen descargada dentro del proyecto setear el Build Action como Embedded Resource
            'Propiedades->Buid Action->EmbeddedResource'
          Una vez hecho esto, se puede acceder a ese recurso utilizando la ruta desde la base del proyecto separada por puntos, por ejemplo:
            'image.Source = ImageSource.FromResource("HelloWorld.Images.background.jpg");'

        - Para hacer esto en XAML es necesario seguir los siguientes pasos:
            - 1° Crear una Markup Extension personalizada:
                - Es una clase que hereda de IMarkupExtension.
                - Tiene una propiedad donde se guardara el ResourceId 
                - Implementa el metodo ProvideValue, donde se devolvera el ImageSource.
                - La clase tiene la siguiente metaetiqueta:
                    '[ContentProperty("ResourceId")]'
                  Que setea como content por default a la propiedad ResourceId, en este caso.
            - 2° Agrega al archivo XAML el namespace del Markup Extension   
                - En la etiqueta ContentPage se agrega la siguiente linea
                    'xmlns:local="clr-namespace:HelloWorld.MarkupExtensions; assembly=HelloWorld"'
            - 3° Utilizar el Markup Extension
                '<Image x:Name="image" Source="{local:EmbeddedImage HelloWorld.Images.background.jpg}" Aspect="AspectFill"/>'
    
    Imagenes específicas para cada plataforma
        Una misma imagen puede ser renderizada en diferentes resoluciones dependiendo del dispositivo, por ello hay que incluir una misma imagen
        en diferentes resoluciones para cada plataforma.
            - iOS: Las imagenes van en una misma carpeta de la siguiente manera:
                clock.png (32x32) - Resolucion Original
                clock@2x.png (64x64) - Resolucion Original x 2
                clock@3x.png (96x96) - Resolucion Original x 3
            - Android: Las imagenes van separadas en carpetas de acuerdo a su resolucion, siguiendo la siguiente convencion:
                drawable (32x32) - Resolucion Original
                drawable-hdpi (48x48) - Resolucion Original x 1.5
                drawable-xhdpi (64x64) - Resolucion Original x 2
                drawable-xxhdpi (96x96) - Resolucion Original x 3
        - Los nombres de los archivos solo pueden contener:
            - Letras minúsculas
            - Números
            - Guión bajo
            - Punto

        Utilizar una imagen local:
            - XAML
                - General
                    '<Button x:Name="btn" Image="clock.png">'

                - Por plataforma
                    '<Button x:Name="btn">
                        <Button.Image>
                            <OnPlatform x:TypeArguments="FileImageSource"
                                        iOS="clock.png"
                                        Android="clock.png"
                                        WinPhone="images/clock.png"/>
                        </Button.Image>
                    </Button>'

            - Codigo
                - General
                    'btn.Image = (FileImageSource)ImageSource.FromFile("clock.png");'

                - Por plataforma
                    'btn.Image = (FileImageSource)ImageSource.FromFile(
                        Device.OnPlatform(
                        iOS: "clock.png",
                        Android: "clock.png",
                        WinPhone: "clock.png"
                    ));'

    Cambiar ícono de la aplicación
        - Android:
            'Proyecto Android->Propiedades->Android Manifest->Application Icon'

    Imagenes redondeadas en Xamarin.forms
        Para trabajar con imagenes redondeadas en Xamarin.Forms debemos instalar el plugin: ImageCirclePlugin
            'https://github.com/jamesmontemagno/ImageCirclePlugin'

        1° Instalar el plugin desde el Package Manager en todos los proyectos
        2° Configurar en cada proyecto agregando la linea 'ImageCircleRenderer.Init();' debajo de la linea 'Xamarin.Forms.Init()' en los archivos:
            iOS: AppDelegate.cs
            Android: MainActivity.cs
        3° Agregar el namespace del plugin en el archivo XAML
            'xmlns:ic="clr-namespace:ImageCircle.Forms.Plugin.Abstractions;assembly=ImageCircle.Forms.Plugin.Abstractions"'
        4° Utilizar el plugin de la siguiente manera
            '<ic:CircleImage WidthRequest="100" HeightRequest="100" Aspect="AspectFill" 
                             Source="https://placeimg.com/400/300/nature" 
                             HorizontalOptions="Center" VerticalOptions="Center"/>'
            
            Nota: el WidthRequest y el HeightRequest deben ser iguales y el aspect debe ser AspectFill

Listas
    '<ListView x:Name="listView"/>'

    - Rellenar una lista con información simple
        - Para rellenar una lista desde el código es necesario setear su propiedad ItemsSource 
            'listView.ItemsSource = names;'
            
    - La linea que separa cada item de la lista se llama Separator y podemos ocultarlo o cambiar su color

    - Rellenar una lista con un objeto
        Cuando la propiedad ItemsSource del ListView es una lista de objetos debemos mostrar sus propiedades de la siguiente manera:
            - 1° Dentro de la propiedad ItemTemplate: '<ListView.ItemTemplate>'
            - 2° Dentro del elemento DataTemplate: '<DataTemplate>'        
            - 3° Podemos utilizar los tipos de celdas que ya vienen por defecto:
                    - TextCell
                        '<TextCell Text="{Binding Name}" Detail="{Binding Status}"/>'
                    - ImageCell
                        '<ImageCell Text="{Binding Name}" Detail="{Binding Status}" ImageSource="{Binding ImageUrl}"/>'
            - 4° O podemos crear una celda personalizada, para ello utilzamos la etiqueta ViewCell y dentro de ella podemos armar la estructura 
            que deseemos.
                - En caso de que los elementos queden fuera de lugar, hay que setear la propiedad HasUnevenRows del ListView a TypeArguments    
    
    - Agrupar lista
        1° Crear una clase que herede que List<LoQueSea> y que tenga un título
           'public class ContactGroup : List<Contact>
            {
                public string Title { get; set; }
                public string ShortTitle { get; set; }

                public ContactGroup(string title, string shortTitle)
                {
                    Title = title;
                    ShortTitle = shortTitle;
                }
            }'
        2° En la propiedad ItemsSource del objeto rellenarlo de la siguiente manera
           'listView.ItemsSource = new List<ContactGroup>
            {
                new ContactGroup("M", "M")
                {
                    new Contact{ Name = "Mosh", ImageUrl = "http://lorempixel.com/100/100/people/1" },
                },
                new ContactGroup("J", "J")
                {
                    new Contact{ Name = "John", ImageUrl = "http://lorempixel.com/100/100/people/2", Status = "Hey, let's talk" }
                }
            };'
        3° Agregar al ListView las propiedades IsGroupingEnabled(true), GroupDisplayBinding(titulo del grupo) y GroupShortNameBinding(titulo del grupo para la barra del costado)

    - ItemSelected y ItemTapped
        Cuando un item se toca por primera vez, se dispara el evento ItemSelected y se pinta de un color, en cambio cada vez que se toca un item se 
        dispara el evento ItemTapped pero no se pinta de ningun color.

            - Desactivar la seleccion de items: para lograr esto hay que tener un handler para cuando se produzca el evento ItemSelected y dentro de
            ese handler ingresar el siguiente código:
                'listView.SelectedItem = null'
           
    - Context Actions
    Las Context Actions nos permite tener un menu de acciones para cada item del listview. Para agregar Context Actions a una celda es necesario:
        1° Dentro de la celda agregar el elemento <Text/Image/ViewCell.ContextActions>
        2° Dentro de las Context Actions agregar los diferentes MenuItems como el siguiente:
            '<MenuItem Text="Call" Clicked="Call_Clicked" CommandParameter="{Binding .}"/>'
            En este caso, se esta creando un MenuItem llamado "Call" que tiene un handler llamado "Call_Clicked" y que envia al handler el
            BindingContext a través del atributo CommandParameter. Se utiliza el punto para enviar el BindingContext en general y no una propiedad
            específica.
        3° Crear un handler para el evento Clicked del MenuItem
    
    - Observable Collection
    Una Observable Collection funciona de manera muy similar a un List tradicional, pero tiene la ventaja que cuando se actualiza uno o varios de sus
    elementos, tambien actualiza el ListView al que este vinculado.
    
    - Pull To Refresh
    Para habilitar el Pull To Refresh en una lista, debemos seguir estos pasos:
        1° Setear la propiedad "IsPullToRefreshEnabled" a True y en la propiedad "Refreshing" ingresar el nombre del handler que se va a encargar de actualizar la lista
        2° En el handler, actualizar la lista como se crea conveniente
        3° Finalizar la actualizacion con esta línea: 'listView.EndRefresh();'

    - Search Bar
    Para utilizar una Search Bar solo hace falta agregarla a la vista asignandole un handler para el evento on "TextChanged" o el evento "SearchButtonPressed":
        '<SearchBar Placeholder="Search..." TextChanged="TextChanged"/>'

        'private void TextChanged(object sender, TextChangedEventArgs e)
        {            
            listView.ItemsSource = GetContacts(e.NewTextValue);
        }'

    
